@using com.usagemeter.androidapp.Models
@using com.usagemeter.androidapp.Services
@inject IJSRuntime JSRuntime
@inject ISettingsService SettingsService

@if (IsVisible && BlockedRule != null)
{
    <div class="rule-block-overlay" @onclick:preventDefault="true" @onclick:stopPropagation="true">
        <div class="rule-block-modal">
            <div class="block-header">
                <div class="block-icon">⏰</div>
                <h2 class="block-title">Time Limit Reached</h2>
            </div>

            <div class="block-content">
                <h3 class="rule-name">@BlockedRule.Name</h3>
                <p class="block-message">
                    You've reached your daily time limit for the selected apps.
                    @if (Settings?.BlockingMode == "Timer")
                    {
                        <span>Please wait for the countdown to continue.</span>
                    }
                    else if (Settings?.BlockingMode == "Instant")
                    {
                        <span>The app has been closed to help you maintain healthy usage habits.</span>
                    }
                    else
                    {
                        <span>Choose how you'd like to proceed.</span>
                    }
                </p>

                <div class="usage-summary">
                    <div class="usage-detail">
                        <span class="usage-label">Daily Limit:</span>
                        <span class="usage-value">@FormatTime(BlockedRule.ThresholdInMilliseconds)</span>
                    </div>
                    <div class="usage-detail">
                        <span class="usage-label">Monitored Apps:</span>
                        <span class="usage-value">@string.Join(", ", BlockedRule.SelectedAppNames.Take(3))@(BlockedRule.SelectedAppNames.Count > 3 ? "..." : "")</span>
                    </div>
                    @if (BlockedRule.ActionType == "OpenApp" && !string.IsNullOrEmpty(BlockedRule.TargetAppName))
                    {
                        <div class="usage-detail">
                            <span class="usage-label">Suggested App:</span>
                            <span class="usage-value">@BlockedRule.TargetAppName</span>
                        </div>
                    }
                </div>

                @if (Settings?.BlockingMode == "Timer" || (Settings?.BlockingMode == "Choice" && UserChoseWait))
                {
                    <div class="countdown-section">
                        <p class="countdown-text">You can continue in:</p>
                        <div class="countdown-timer">@CountdownText</div>
                        <div class="countdown-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: @ProgressPercentage%"></div>
                            </div>
                        </div>
                        @if (Settings?.BlockingMode == "Choice" && !UserChoseWait)
                        {
                            <button class="btn-skip" @onclick="SkipTimer">Skip Timer</button>
                        }
                    </div>
                }
            </div>

            <div class="block-actions">
                @if (Settings?.BlockingMode == "Choice" && !UserChoseWait)
                {
                    <h4>What would you like to do?</h4>

                    <button class="btn-block choice" @onclick="ChooseWait">
                        <span class="btn-icon">⏳</span>
                        Wait @(Settings.DefaultBlockDurationMinutes)m @(Settings.DefaultBlockDurationSeconds)s
                    </button>

                    <button class="btn-block choice" @onclick="GoHome">
                        <span class="btn-icon">🏠</span>
                        Go to Home Screen
                    </button>

                    @if (BlockedRule.ActionType == "OpenApp" && !string.IsNullOrEmpty(BlockedRule.TargetAppName))
                    {
                        <button class="btn-block choice primary" @onclick="OpenTargetApp">
                            <span class="btn-icon">🚀</span>
                            Open @BlockedRule.TargetAppName
                        </button>
                    }

                    <button class="btn-block choice secondary" @onclick="Acknowledge">
                        <span class="btn-icon">✓</span>
                        Dismiss (Not Recommended)
                    </button>
                }
                else if (Settings?.BlockingMode == "Timer" || UserChoseWait)
                {
                    @if (CountdownSeconds <= 0)
                    {
                        <button class="btn-block primary" @onclick="Acknowledge">
                            <span class="btn-icon">✓</span>
                            Continue
                        </button>
                    }
                    else
                    {
                        <button class="btn-block disabled" disabled>
                            <span class="btn-icon">⏳</span>
                            Wait @CountdownText
                        </button>
                    }

                    @if (BlockedRule.ActionType == "OpenApp" && !string.IsNullOrEmpty(BlockedRule.TargetAppName))
                    {
                        <button class="btn-block secondary" @onclick="OpenTargetApp" disabled="@(CountdownSeconds > 0)">
                            <span class="btn-icon">🚀</span>
                            Open @BlockedRule.TargetAppName Instead
                        </button>
                    }
                }
                else
                {
                    <button class="btn-block primary" @onclick="GoHome">
                        <span class="btn-icon">🏠</span>
                        Go to Home
                    </button>

                    @if (BlockedRule.ActionType == "OpenApp" && !string.IsNullOrEmpty(BlockedRule.TargetAppName))
                    {
                        <button class="btn-block secondary" @onclick="OpenTargetApp">
                            <span class="btn-icon">🚀</span>
                            Open @BlockedRule.TargetAppName
                        </button>
                    }
                }
            </div>

            <div class="block-footer">
                <p class="footer-text">
                    💡 Tip: Taking breaks from apps helps maintain healthy digital habits.
                    You can modify these settings in the Settings menu.
                </p>
            </div>
        </div>
    </div>
}

@code {
    [Parameter] public bool IsVisible { get; set; }
    [Parameter] public AppRule? BlockedRule { get; set; }
    [Parameter] public EventCallback OnAcknowledge { get; set; }
    [Parameter] public EventCallback<string> OnOpenApp { get; set; }
    [Parameter] public int CountdownSeconds { get; set; } = 0;

    private AppSettings? Settings;
    private bool UserChoseWait = false;
    private Timer? CountdownTimer;
    private int InitialCountdown = 0;

    private string CountdownText
    {
        get
        {
            if (CountdownSeconds <= 0) return "0s";
            var minutes = CountdownSeconds / 60;
            var seconds = CountdownSeconds % 60;
            if (minutes > 0)
                return $"{minutes}m {seconds}s";
            return $"{seconds}s";
        }
    }

    private double ProgressPercentage => InitialCountdown > 0
        ? ((InitialCountdown - CountdownSeconds) / (double)InitialCountdown) * 100
        : 100;

    protected override async Task OnInitializedAsync()
    {
        Settings = await SettingsService.GetSettingsAsync();

        // Set initial countdown based on settings
        if (Settings.BlockingMode == "Timer")
        {
            InitialCountdown = Settings.DefaultBlockDurationMinutes * 60 + Settings.DefaultBlockDurationSeconds;
            CountdownSeconds = InitialCountdown;
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (IsVisible && Settings?.BlockingMode == "Timer" && CountdownSeconds > 0)
        {
            StartCountdownTimer();
            await PreventBackNavigation();
        }
        else if (IsVisible && Settings?.BlockingMode == "Instant")
        {
            // For instant mode, immediately go home
            await Task.Delay(1000); // Brief delay to show message
            await GoHome();
        }
    }

    private void ChooseWait()
    {
        UserChoseWait = true;
        InitialCountdown = Settings!.DefaultBlockDurationMinutes * 60 + Settings.DefaultBlockDurationSeconds;
        CountdownSeconds = InitialCountdown;
        StartCountdownTimer();
        StateHasChanged();
    }

    private void StartCountdownTimer()
    {
        CountdownTimer?.Dispose();

        CountdownTimer = new Timer(_ =>
        {
            if (CountdownSeconds > 0)
            {
                CountdownSeconds--;
                InvokeAsync(StateHasChanged);
            }
            else
            {
                CountdownTimer?.Dispose();
                InvokeAsync(StateHasChanged);
            }
        }, null, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1));
    }

    private void SkipTimer()
    {
        CountdownSeconds = 0;
        CountdownTimer?.Dispose();
        StateHasChanged();
    }

    private async Task GoHome()
    {
        await CleanupNavigation();
        await OnAcknowledge.InvokeAsync();
    }

    private async Task OpenTargetApp()
    {
        if (BlockedRule?.TargetPackage != null)
        {
            await CleanupNavigation();
            await OnOpenApp.InvokeAsync(BlockedRule.TargetPackage);
        }
    }

    private async Task Acknowledge()
    {
        await CleanupNavigation();
        await OnAcknowledge.InvokeAsync();
    }

    private async Task PreventBackNavigation()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", @"
                // Prevent back button
                if (typeof window.ruleBlockHistoryHandler === 'undefined') {
                    window.ruleBlockHistoryHandler = function(event) {
                        if (document.querySelector('.rule-block-overlay')) {
                            history.pushState(null, null, location.href);
                            event.preventDefault();
                            return false;
                        }
                    };

                    history.pushState(null, null, location.href);
                    window.addEventListener('popstate', window.ruleBlockHistoryHandler);
                }

                // Prevent keyboard shortcuts
                if (typeof window.ruleBlockKeyHandler === 'undefined') {
                    window.ruleBlockKeyHandler = function(e) {
                        if (document.querySelector('.rule-block-overlay')) {
                            if (e.key === 'Escape' || e.key === 'F5' ||
                                (e.ctrlKey && (e.key === 'r' || e.key === 'R')) ||
                                (e.ctrlKey && e.shiftKey && (e.key === 'i' || e.key === 'I')) ||
                                e.key === 'F12') {
                                e.preventDefault();
                                e.stopPropagation();
                                return false;
                            }
                        }
                    };

                    document.addEventListener('keydown', window.ruleBlockKeyHandler, true);
                }
            ");
        }
        catch (Exception)
        {
            // JavaScript execution failed, but this isn't critical
        }
    }

    private async Task CleanupNavigation()
    {
        try
        {
            CountdownTimer?.Dispose();

            await JSRuntime.InvokeVoidAsync("eval", @"
                // Clean up event handlers
                if (typeof window.ruleBlockHistoryHandler !== 'undefined') {
                    window.removeEventListener('popstate', window.ruleBlockHistoryHandler);
                    delete window.ruleBlockHistoryHandler;
                }

                if (typeof window.ruleBlockKeyHandler !== 'undefined') {
                    document.removeEventListener('keydown', window.ruleBlockKeyHandler, true);
                    delete window.ruleBlockKeyHandler;
                }
            ");
        }
        catch (Exception)
        {
            // JavaScript cleanup failed, but this isn't critical
        }
    }

    private string FormatTime(long milliseconds)
    {
        var time = TimeSpan.FromMilliseconds(milliseconds);
        var parts = new List<string>();

        if (time.Hours > 0) parts.Add($"{time.Hours}h");
        if (time.Minutes > 0) parts.Add($"{time.Minutes}m");
        if (parts.Count == 0 && time.Seconds > 0) parts.Add($"{time.Seconds}s");

        return parts.Count > 0 ? string.Join(" ", parts) : "0m";
    }

    public void Dispose()
    {
        CountdownTimer?.Dispose();
    }
}